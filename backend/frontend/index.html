
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cambium Bot Training Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #667eea;
            font-size: 2em;
        }

        .status-indicator {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .status-online {
            background: #10b981;
            color: white;
        }

        .status-offline {
            background: #ef4444;
            color: white;
        }

        .refresh-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .refresh-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 2vh;
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
        }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
        }

        tr:hover {
            background: #f3f4f6;
        }

        .status-ready {
            color: #10b981;
            font-weight: 600;
        }

        .status-fighting {
            color: #f59e0b;
            font-weight: 600;
        }

        .status-dead {
            color: #ef4444;
            font-weight: 600;
        }

        .arena-open {
            color: #10b981;
            font-weight: 600;
        }

        .arena-closed {
            color: #ef4444;
            font-weight: 600;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .config-section {
            margin-top: 20px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .config-label {
            font-weight: 600;
            color: #667eea;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .error {
            background: #fee2e2;
            color: #dc2626;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .log-console {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .log-entry {
            padding: 8px;
            margin: 4px 0;
            border-left: 3px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 4px;
        }

        .log-entry:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .log-timestamp {
            color: #10b981;
            font-weight: 600;
        }

        .log-metric {
            color: #f59e0b;
        }

        .log-value {
            color: #60a5fa;
        }

        .log-bot {
            color: #a78bfa;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Cambium Bot Training Dashboard</h1>
            <div class="status-indicator">
                <span class="status-badge" id="connectionStatus">Connecting...</span>
                <button class="refresh-btn" onclick="refreshData()">üîÑ Refresh</button>
            </div>
        </div>

        <div class="stats-grid" id="statsGrid"></div>

        <!-- Master Bot Selector -->
        <div class="card" style="margin-bottom: 20px;">
            <h2>üéØ Select Bot to Monitor</h2>
            <div style="margin-bottom: 15px;">
                <label for="masterBotSelector" style="display: block; margin-bottom: 8px; font-weight: 600; color: #667eea;">Bot Selection (filters all bot-specific views below):</label>
                <select id="masterBotSelector" style="width: 100%; padding: 10px; border-radius: 8px; border: 2px solid #e5e7eb; font-size: 1em;" onchange="onMasterBotChange()">
                    <option value="">-- All Bots (Global View) --</option>
                </select>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>ü§ñ Bots Status</h2>
                <div class="table-container">
                    <table id="botsTable">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Status</th>
                                <th>Pair</th>
                                <th>Arena</th>
                                <th>Model</th>
                                <th>Tick Rate</th>
                            </tr>
                        </thead>
                        <tbody id="botsTableBody">
                            <tr><td colspan="6" class="loading">Loading...</tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card">
                <h2>‚öîÔ∏è Arenas</h2>
                <div class="table-container">
                    <table id="arenasTable">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Status</th>
                                <th>Spawn Coords</th>
                            </tr>
                        </thead>
                        <tbody id="arenasTableBody">
                            <tr><td colspan="3" class="loading">Loading...</tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üìä Training Metrics</h2>
                <div class="chart-container">
                    <canvas id="trainingChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>‚ö° Bot Performance</h2>
                <div class="chart-container">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üìà Reward Progression (per 100 ticks)</h2>
                <div class="chart-container">
                    <canvas id="rewardChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>üìâ Loss Progression</h2>
                <div class="chart-container">
                    <canvas id="lossChart"></canvas>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üìã Training Logs (Every 100 Ticks)</h2>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <button class="refresh-btn" onclick="clearLogs()" style="background: #ef4444;">Clear Logs</button>
                <span style="color: #667eea; font-weight: 600;" id="logCount">0 logs</span>
            </div>
            <div class="log-console" id="logConsole">
                <div class="log-entry">Waiting for training data...</div>
            </div>
        </div>

        <div class="card">
            <h2>üëÅÔ∏è Bot Observation Viewer</h2>
            <div id="observationViewer" style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; max-height: 500px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.85em;">
                <div style="text-align: center; padding: 20px; color: #667eea;">Select a bot from the dropdown above to view its observation data</div>
            </div>
        </div>

        <div class="card">
            <h2>üéÅ Reward Events Log</h2>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <button class="refresh-btn" onclick="updateRewardEvents()" style="background: #667eea;">üîÑ Refresh</button>
                <span style="color: #667eea; font-weight: 600;" id="rewardEventCount">0 events</span>
            </div>
            <div id="rewardEventsViewer" style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; max-height: 600px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.85em;">
                <div style="text-align: center; padding: 20px; color: #667eea;">Select a bot from the dropdown above to view its reward events</div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>‚öôÔ∏è Action Space Config</h2>
                <div class="config-section" id="actionSpaceConfig"></div>
            </div>

            <div class="card">
                <h2>üëÅÔ∏è Observation Space Config</h2>
                <div class="config-section" id="observationSpaceConfig"></div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin;
        let trainingChart = null;
        let performanceChart = null;
        let rewardChart = null;
        let lossChart = null;
        let trainingData = [];
        let performanceData = {};
        let rewardProgressionData = [];
        let lossProgressionData = [];

        // Initialize charts
        function initCharts() {
            const trainingCtx = document.getElementById('trainingChart').getContext('2d');
            trainingChart = new Chart(trainingCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Total Samples',
                        data: [],
                        borderColor: 'rgb(102, 126, 234)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });

            const performanceCtx = document.getElementById('performanceChart').getContext('2d');
            performanceChart = new Chart(performanceCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Tick Rate (TPS)',
                        data: [],
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: 'rgb(102, 126, 234)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 25
                        }
                    }
                }
            });

            const rewardCtx = document.getElementById('rewardChart').getContext('2d');
            rewardChart = new Chart(rewardCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Total Rewards',
                        data: [],
                        borderColor: 'rgb(16, 185, 129)',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: true,
                        yAxisID: 'y'
                    }, {
                        label: 'Avg Reward per Sample',
                        data: [],
                        borderColor: 'rgb(245, 158, 11)',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        tension: 0.4,
                        fill: false,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });

            const lossCtx = document.getElementById('lossChart').getContext('2d');
            lossChart = new Chart(lossCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Training Loss',
                        data: [],
                        borderColor: 'rgb(239, 68, 68)',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        async function fetchGameState() {
            try {
                const response = await fetch(`${API_BASE}/game-state`);
                if (!response.ok) throw new Error('Failed to fetch game state');
                return await response.json();
            } catch (error) {
                console.error('Error fetching game state:', error);
                throw error;
            }
        }

        async function fetchStats() {
            try {
                const response = await fetch(`${API_BASE}/stats`);
                if (!response.ok) throw new Error('Failed to fetch stats');
                return await response.json();
            } catch (error) {
                console.error('Error fetching stats:', error);
                throw error;
            }
        }

        async function fetchTrainingLogs() {
            try {
                const response = await fetch(`${API_BASE}/training-logs`);
                if (!response.ok) throw new Error('Failed to fetch training logs');
                return await response.json();
            } catch (error) {
                console.error('Error fetching training logs:', error);
                throw error;
            }
        }

        async function fetchRewardProgression() {
            try {
                const response = await fetch(`${API_BASE}/reward-progression`);
                if (!response.ok) throw new Error('Failed to fetch reward progression');
                return await response.json();
            } catch (error) {
                console.error('Error fetching reward progression:', error);
                throw error;
            }
        }

        async function fetchBotObservation(botName) {
            try {
                const response = await fetch(`${API_BASE}/bot-observation/${botName}`);
                if (!response.ok) throw new Error('Failed to fetch bot observation');
                return await response.json();
            } catch (error) {
                console.error('Error fetching bot observation:', error);
                throw error;
            }
        }

        function formatObservation(obs) {
            if (!obs) return '<div style="color: #ef4444;">No observation data</div>';
            
            let html = '<div style="line-height: 1.8;">';
            
            // Player data
            if (obs.player) {
                html += '<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Player Data:</strong><br>';
                html += `  Health: <span style="color: #60a5fa;">${obs.player.health || 0}</span><br>`;
                html += `  Position: <span style="color: #60a5fa;">(${obs.player.x?.toFixed(2) || 0}, ${obs.player.y?.toFixed(2) || 0}, ${obs.player.z?.toFixed(2) || 0})</span><br>`;
                html += `  Rotation: <span style="color: #60a5fa;">Yaw: ${obs.player.yaw?.toFixed(2) || 0}¬∞, Pitch: ${obs.player.pitch?.toFixed(2) || 0}¬∞</span><br>`;
                html += `  Armor: <span style="color: #60a5fa;">${obs.player.armor || 0}</span><br>`;
                html += '</div>';
            }
            
            // Entities
            if (obs.entities && obs.entities.length > 0) {
                html += `<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Entities (${obs.entities.length}):</strong><br>`;
                obs.entities.slice(0, 5).forEach((entity, idx) => {
                    html += `  <span style="color: #a78bfa;">Entity ${idx + 1}:</span> `;
                    html += `Type: <span style="color: #60a5fa;">${entity.isPlayer ? 'Player' : entity.isProjectile ? 'Projectile' : 'Other'}</span>, `;
                    html += `Health: <span style="color: #60a5fa;">${entity.health || 0}</span>, `;
                    html += `Pos: <span style="color: #60a5fa;">(${entity.relativeX?.toFixed(2) || 0}, ${entity.relativeY?.toFixed(2) || 0}, ${entity.relativeZ?.toFixed(2) || 0})</span><br>`;
                });
                if (obs.entities.length > 5) {
                    html += `  <span style="color: #f59e0b;">... and ${obs.entities.length - 5} more</span><br>`;
                }
                html += '</div>';
            }
            
            // Blocks
            if (obs.blocks && obs.blocks.length > 0) {
                html += `<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Blocks (${obs.blocks.length}):</strong><br>`;
                obs.blocks.slice(0, 5).forEach((block, idx) => {
                    html += `  <span style="color: #a78bfa;">Block ${idx + 1}:</span> `;
                    html += `Pos: <span style="color: #60a5fa;">(${block.x || 0}, ${block.y || 0}, ${block.z || 0})</span>, `;
                    html += `Dist: <span style="color: #60a5fa;">${block.distance?.toFixed(2) || 0}</span>, `;
                    html += `Solid: <span style="color: #60a5fa;">${block.solid ? 'Yes' : 'No'}</span><br>`;
                });
                if (obs.blocks.length > 5) {
                    html += `  <span style="color: #f59e0b;">... and ${obs.blocks.length - 5} more</span><br>`;
                }
                html += '</div>';
            }
            
            // Inventory
            if (obs.inventory && obs.inventory.length > 0) {
                html += `<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Inventory (${obs.inventory.length} slots):</strong><br>`;
                obs.inventory.forEach((inv, idx) => {
                    if (inv.count > 0) {
                        html += `  Slot ${idx}: <span style="color: #60a5fa;">Count: ${inv.count}</span>`;
                        if (inv.isWeapon) {
                            html += `, <span style="color: #ef4444;">Weapon</span> (Damage: ${inv.weaponDamage || 0})`;
                        }
                        html += '<br>';
                    }
                });
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        async function fetchBotObservation(botName) {
            try {
                const response = await fetch(`${API_BASE}/bot-observation/${botName}`);
                if (!response.ok) throw new Error('Failed to fetch bot observation');
                return await response.json();
            } catch (error) {
                console.error('Error fetching bot observation:', error);
                throw error;
            }
        }

        function formatObservation(obs) {
            if (!obs) return '<div style="color: #ef4444;">No observation data</div>';
            
            let html = '<div style="line-height: 1.8;">';
            
            // Player data
            if (obs.player) {
                html += '<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Player Data:</strong><br>';
                html += `  Health: <span style="color: #60a5fa;">${obs.player.health || 0}</span><br>`;
                html += `  Position: <span style="color: #60a5fa;">(${obs.player.x?.toFixed(2) || 0}, ${obs.player.y?.toFixed(2) || 0}, ${obs.player.z?.toFixed(2) || 0})</span><br>`;
                html += `  Rotation: <span style="color: #60a5fa;">Yaw: ${obs.player.yaw?.toFixed(2) || 0}¬∞, Pitch: ${obs.player.pitch?.toFixed(2) || 0}¬∞</span><br>`;
                html += `  Armor: <span style="color: #60a5fa;">${obs.player.armor || 0}</span><br>`;
                html += '</div>';
            }
            
            // Entities
            if (obs.entities && obs.entities.length > 0) {
                html += `<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Entities (${obs.entities.length}):</strong><br>`;
                obs.entities.slice(0, 5).forEach((entity, idx) => {
                    html += `  <span style="color: #a78bfa;">Entity ${idx + 1}:</span> `;
                    html += `Type: <span style="color: #60a5fa;">${entity.isPlayer ? 'Player' : entity.isProjectile ? 'Projectile' : 'Other'}</span>, `;
                    html += `Health: <span style="color: #60a5fa;">${entity.health || 0}</span>, `;
                    html += `Pos: <span style="color: #60a5fa;">(${entity.relativeX?.toFixed(2) || 0}, ${entity.relativeY?.toFixed(2) || 0}, ${entity.relativeZ?.toFixed(2) || 0})</span><br>`;
                });
                if (obs.entities.length > 5) {
                    html += `  <span style="color: #f59e0b;">... and ${obs.entities.length - 5} more</span><br>`;
                }
                html += '</div>';
            }
            
            // Blocks
            if (obs.blocks && obs.blocks.length > 0) {
                html += `<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Blocks (${obs.blocks.length}):</strong><br>`;
                obs.blocks.slice(0, 5).forEach((block, idx) => {
                    html += `  <span style="color: #a78bfa;">Block ${idx + 1}:</span> `;
                    html += `Pos: <span style="color: #60a5fa;">(${block.x || 0}, ${block.y || 0}, ${block.z || 0})</span>, `;
                    html += `Dist: <span style="color: #60a5fa;">${block.distance?.toFixed(2) || 0}</span>, `;
                    html += `Solid: <span style="color: #60a5fa;">${block.solid ? 'Yes' : 'No'}</span><br>`;
                });
                if (obs.blocks.length > 5) {
                    html += `  <span style="color: #f59e0b;">... and ${obs.blocks.length - 5} more</span><br>`;
                }
                html += '</div>';
            }
            
            // Inventory
            if (obs.inventory && obs.inventory.length > 0) {
                html += `<div style="margin-bottom: 15px;"><strong style="color: #10b981;">Inventory (${obs.inventory.length} slots):</strong><br>`;
                obs.inventory.forEach((inv, idx) => {
                    if (inv.count > 0) {
                        html += `  Slot ${idx}: <span style="color: #60a5fa;">Count: ${inv.count}</span>`;
                        if (inv.isWeapon) {
                            html += `, <span style="color: #ef4444;">Weapon</span> (Damage: ${inv.weaponDamage || 0})`;
                        }
                        html += '<br>';
                    }
                });
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        async function updateBotObservation() {
            const viewer = document.getElementById('observationViewer');
            const botName = getSelectedBot();
            
            if (!botName) {
                viewer.innerHTML = '<div style="text-align: center; padding: 20px; color: #667eea;">Select a bot from the dropdown above to view its observation data</div>';
                return;
            }
            
            try {
                const data = await fetchBotObservation(botName);
                if (data.status === 'success') {
                    viewer.innerHTML = `
                        <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #667eea;">
                            <strong style="color: #667eea;">Bot: ${data.bot_name}</strong><br>
                            <span style="color: #f59e0b;">Tick Count: ${data.tick_count}</span><br>
                            <span style="color: #10b981;">Last Updated: ${new Date(data.timestamp).toLocaleString()}</span>
                        </div>
                        ${formatObservation(data.observation)}
                    `;
                } else {
                    viewer.innerHTML = `<div style="color: #ef4444;">${data.message || 'Error loading observation'}</div>`;
                }
            } catch (error) {
                viewer.innerHTML = `<div style="color: #ef4444;">Error: ${error.message}</div>`;
            }
        }

        function updateStatsGrid(stats) {
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Bots</div>
                    <div class="stat-value">${stats.total_bots || 0}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Active Duels</div>
                    <div class="stat-value">${stats.active_bots || 0}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Ready Bots</div>
                    <div class="stat-value">${stats.ready_bots || 0}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Open Arenas</div>
                    <div class="stat-value">${stats.open_arenas || 0}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Training Samples</div>
                    <div class="stat-value">${stats.ppo_samples || 0}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Rewards</div>
                    <div class="stat-value">${stats.ppo_rewards || 0}</div>
                </div>
            `;
        }

        function updateBotsTable(bots) {
            const tbody = document.getElementById('botsTableBody');
            if (bots.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No bots found</td></tr>';
                return;
            }

            tbody.innerHTML = bots.map(bot => `
                <tr>
                    <td><strong>${bot.name}</strong></td>
                    <td><span class="status-${bot.status}">${bot.status.toUpperCase()}</span></td>
                    <td>${bot.pair || 'None'}</td>
                    <td>${bot.arena || 'None'}</td>
                    <td>v${bot.model_version}</td>
                    <td>${bot.tick_rate.toFixed(2)} TPS</td>
                </tr>
            `).join('');
        }

        function updateArenasTable(arenas) {
            const tbody = document.getElementById('arenasTableBody');
            if (arenas.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">No arenas found</td></tr>';
                return;
            }

            tbody.innerHTML = arenas.map(arena => `
                <tr>
                    <td><strong>${arena.name}</strong></td>
                    <td><span class="arena-${arena.status}">${arena.status.toUpperCase()}</span></td>
                    <td>${arena.spawn_coords.map(c => `[${c.join(', ')}]`).join(', ')}</td>
                </tr>
            `).join('');
        }

        function updateTrainingChart(training) {
            const now = new Date().toLocaleTimeString();
            trainingData.push({
                time: now,
                samples: training.total_samples
            });

            // Keep only last 20 data points
            if (trainingData.length > 20) {
                trainingData.shift();
            }

            trainingChart.data.labels = trainingData.map(d => d.time);
            trainingChart.data.datasets[0].data = trainingData.map(d => d.samples);
            trainingChart.update('none');
        }

        function updatePerformanceChart(bots) {
            const botNames = bots.map(b => b.name);
            const tickRates = bots.map(b => b.tick_rate);

            performanceChart.data.labels = botNames;
            performanceChart.data.datasets[0].data = tickRates;
            performanceChart.update('none');
        }

        function updateConfigSections(actionSpace, observationSpace) {
            const actionConfig = document.getElementById('actionSpaceConfig');
            actionConfig.innerHTML = Object.entries(actionSpace).map(([key, value]) => `
                <div class="config-item">
                    <span class="config-label">${key}:</span>
                    <span>${typeof value === 'boolean' ? (value ? '‚úì' : '‚úó') : value}</span>
                </div>
            `).join('');

            const obsConfig = document.getElementById('observationSpaceConfig');
            obsConfig.innerHTML = Object.entries(observationSpace).map(([key, value]) => `
                <div class="config-item">
                    <span class="config-label">${key}:</span>
                    <span>${typeof value === 'boolean' ? (value ? '‚úì' : '‚úó') : value}</span>
                </div>
            `).join('');
        }

        function updateRewardChart(progression) {
            if (!progression || progression.length === 0) return;

            const botName = getSelectedBot();
            let filteredProgression = progression;
            
            // Filter by bot if one is selected
            if (botName) {
                filteredProgression = progression.filter(p => {
                    return p.bot_rewards && p.bot_rewards[botName] !== undefined;
                });
            }

            if (filteredProgression.length === 0) {
                rewardChart.data.labels = [];
                rewardChart.data.datasets[0].data = [];
                rewardChart.data.datasets[1].data = [];
                rewardChart.update('none');
                return;
            }

            const intervals = filteredProgression.map(p => `Interval ${p.interval}`);
            const totalRewards = botName 
                ? filteredProgression.map(p => p.bot_rewards[botName] || 0)
                : filteredProgression.map(p => p.total_rewards);
            const avgRewards = filteredProgression.map(p => p.avg_reward);

            rewardChart.data.labels = intervals;
            rewardChart.data.datasets[0].data = totalRewards;
            rewardChart.data.datasets[1].data = avgRewards;
            rewardChart.update('none');
        }

        function updateLossChart(progression) {
            if (!progression || progression.length === 0) return;

            const botName = getSelectedBot();
            let filteredProgression = progression;
            
            // Filter by bot if one is selected (loss is global, but we can still filter intervals)
            if (botName) {
                filteredProgression = progression.filter(p => {
                    return p.bot_rewards && p.bot_rewards[botName] !== undefined;
                });
            }

            if (filteredProgression.length === 0) {
                lossChart.data.labels = [];
                lossChart.data.datasets[0].data = [];
                lossChart.update('none');
                return;
            }

            const intervals = filteredProgression.map(p => `Interval ${p.interval}`);
            const losses = filteredProgression.map(p => p.loss);

            lossChart.data.labels = intervals;
            lossChart.data.datasets[0].data = losses;
            lossChart.update('none');
        }

        function updateLogConsole(logs) {
            const consoleDiv = document.getElementById('logConsole');
            const countSpan = document.getElementById('logCount');
            const botName = getSelectedBot();
            
            if (!logs || logs.length === 0) {
                consoleDiv.innerHTML = '<div class="log-entry">No training logs yet. Waiting for first 100-tick interval...</div>';
                countSpan.textContent = '0 logs';
                return;
            }

            // Filter logs by bot if one is selected
            let filteredLogs = logs;
            if (botName) {
                filteredLogs = logs.filter(log => {
                    return log.bot_statistics && log.bot_statistics[botName] !== undefined;
                });
            }

            countSpan.textContent = `${filteredLogs.length} logs${botName ? ` (${botName})` : ''}`;

            // Show last 20 logs (oldest first, newest at bottom)
            const recentLogs = filteredLogs.slice(-20);
            const totalLogs = filteredLogs.length;
            const startInterval = totalLogs - recentLogs.length + 1;
            consoleDiv.innerHTML = recentLogs.map((log, idx) => {
                const time = new Date(log.timestamp).toLocaleTimeString();
                const stats = log.training_stats;
                const botStats = log.bot_statistics;
                const intervalNum = startInterval + idx; // Calculate interval number correctly (oldest to newest)
                
                let botInfo = '';
                if (botName) {
                    // Show only selected bot
                    if (botStats[botName]) {
                        const botData = botStats[botName];
                        botInfo = `<span class="log-bot">${botName}</span>: score=<span class="log-value">${botData.score.toFixed(2)}</span>, ticks=<span class="log-value">${botData.tick_count}</span>`;
                    }
                } else {
                    // Show all bots
                    for (const [name, botData] of Object.entries(botStats)) {
                        botInfo += `<span class="log-bot">${name}</span>: score=<span class="log-value">${botData.score.toFixed(2)}</span>, ticks=<span class="log-value">${botData.tick_count}</span>; `;
                    }
                }
                
                return `
                    <div class="log-entry">
                        <div><span class="log-timestamp">[${time}]</span> <span class="log-metric">Interval ${intervalNum}</span></div>
                        <div>
                            <span class="log-metric">Samples:</span> <span class="log-value">${stats.samples_trained}</span> | 
                            <span class="log-metric">Loss:</span> <span class="log-value">${stats.loss.toFixed(4)}</span> | 
                            <span class="log-metric">Total Rewards:</span> <span class="log-value">${stats.total_rewards.toFixed(2)}</span> | 
                            <span class="log-metric">Avg Reward:</span> <span class="log-value">${stats.avg_reward_per_sample.toFixed(4)}</span>
                        </div>
                        <div style="margin-top: 4px; font-size: 0.9em;">
                            ${botInfo}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Auto-scroll to bottom to show newest logs
            setTimeout(() => {
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }, 100);
        }

        function clearLogs() {
            const consoleDiv = document.getElementById('logConsole');
            consoleDiv.innerHTML = '<div class="log-entry">Logs cleared. Waiting for new training data...</div>';
        }

        async function refreshData() {
            const statusBadge = document.getElementById('connectionStatus');
            statusBadge.textContent = 'Refreshing...';
            statusBadge.className = 'status-badge status-online pulse';

            try {
                const [gameState, stats, trainingLogs, rewardProgression] = await Promise.all([
                    fetchGameState(),
                    fetchStats(),
                    fetchTrainingLogs(),
                    fetchRewardProgression()
                ]);

                updateStatsGrid(stats);
                updateBotsTable(gameState.bots);
                updateArenasTable(gameState.arenas);
                updateTrainingChart(gameState.training);
                updatePerformanceChart(gameState.bots);
                updateConfigSections(gameState.action_space, gameState.observation_space);
                updateMasterBotSelector(gameState.bots);
                updateRewardChart(rewardProgression.progression);
                updateLossChart(rewardProgression.progression);
                updateLogConsole(trainingLogs.logs);
                
                // Auto-refresh bot-specific views if a bot is selected
                const botName = getSelectedBot();
                if (botName) {
                    updateBotObservation();
                    updateRewardEvents();
                }

                statusBadge.textContent = 'Connected';
                statusBadge.className = 'status-badge status-online';
            } catch (error) {
                statusBadge.textContent = 'Disconnected';
                statusBadge.className = 'status-badge status-offline';
                console.error('Error refreshing data:', error);
            }
        }

        // Master bot selector functions
        function updateMasterBotSelector(bots) {
            const selector = document.getElementById('masterBotSelector');
            if (!selector) return;
            const currentValue = selector.value;
            
            selector.innerHTML = '<option value="">-- All Bots (Global View) --</option>';
            
            bots.forEach(bot => {
                const option = document.createElement('option');
                option.value = bot.name;
                option.textContent = `${bot.name} (${bot.status})`;
                selector.appendChild(option);
            });
            
            if (currentValue && (currentValue === '' || bots.some(b => b.name === currentValue))) {
                selector.value = currentValue;
            }
        }

        function onMasterBotChange() {
            const botName = getSelectedBot();
            updateBotObservation();
            updateRewardEvents();
            updateRewardChart();
            updateLossChart();
            updateLogConsole();
        }

        function getSelectedBot() {
            const selector = document.getElementById('masterBotSelector');
            return selector ? selector.value : '';
        }

        async function fetchRewardEvents(botName) {
            try {
                const url = botName 
                    ? `${API_BASE}/reward-events?bot_name=${encodeURIComponent(botName)}`
                    : `${API_BASE}/reward-events`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch reward events');
                return await response.json();
            } catch (error) {
                console.error('Error fetching reward events:', error);
                throw error;
            }
        }

        async function updateRewardEvents() {
            const botName = getSelectedBot();
            const viewer = document.getElementById('rewardEventsViewer');
            const countSpan = document.getElementById('rewardEventCount');
            
            if (!botName) {
                viewer.innerHTML = '<div style="text-align: center; padding: 20px; color: #667eea;">Select a bot from the dropdown above to view its reward events</div>';
                countSpan.textContent = '0 events';
                return;
            }
            
            try {
                const data = await fetchRewardEvents(botName);
                console.log('Reward events response for', botName, ':', data); // Debug log
                
                if (!data) {
                    viewer.innerHTML = '<div style="color: #ef4444;">Error: No data received from server</div>';
                    countSpan.textContent = 'Error';
                    return;
                }
                
                if (data.status === 'success') {
                    const events = Array.isArray(data.events) ? data.events : [];
                    countSpan.textContent = `${events.length} events`;
                    
                    if (events.length === 0) {
                        viewer.innerHTML = `
                            <div style="text-align: center; padding: 20px;">
                                <div style="color: #f59e0b; margin-bottom: 10px;">No reward events yet for <strong>${botName}</strong></div>
                                <div style="color: #667eea; font-size: 0.9em;">
                                    Events will appear here when the bot receives rewards:<br>
                                    ‚Ä¢ Damage dealt/taken<br>
                                    ‚Ä¢ Good aim detection<br>
                                    ‚Ä¢ Proximity rewards<br>
                                    ‚Ä¢ Survival rewards<br>
                                    ‚Ä¢ Yaw exploration rewards
                                </div>
                            </div>
                        `;
                        return;
                    }
                    
                    const eventsHtml = events.slice().reverse().map((eventLog) => {
                        const timestamp = new Date(eventLog.timestamp).toLocaleString();
                        const event = eventLog.event || {};
                        const source = eventLog.source || 'mod';
                        const sourceColor = source === 'auto_calculated' ? '#10b981' : '#667eea';
                        const sourceLabel = source === 'auto_calculated' ? 'Auto' : 'Mod';
                        
                        const jsonStr = JSON.stringify(event, null, 2);
                        const formattedJson = jsonStr
                            .replace(/("type":\s*")([^"]+)(")/g, `$1<span style="color: #f59e0b;">$2</span>$3`)
                            .replace(/("amount":\s*)([0-9.]+)/g, `$1<span style="color: #10b981;">$2</span>`)
                            .replace(/("damage_percentage":\s*)([0-9.]+)/g, `$1<span style="color: #10b981;">$2</span>`)
                            .replace(/("distance":\s*)([0-9.]+)/g, `$1<span style="color: #60a5fa;">$2</span>`)
                            .replace(/("yaw":\s*)([0-9.-]+)/g, `$1<span style="color: #a78bfa;">$2</span>`)
                            .replace(/("pitch":\s*)([0-9.-]+)/g, `$1<span style="color: #a78bfa;">$2</span>`);
                        
                        return `
                            <div class="log-entry" style="margin-bottom: 15px; padding: 12px; border-left: 4px solid ${sourceColor};">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span class="log-timestamp">${timestamp}</span>
                                    <span style="color: ${sourceColor}; font-weight: 600; background: rgba(102, 126, 234, 0.1); padding: 2px 8px; border-radius: 4px;">${sourceLabel}</span>
                                </div>
                                <div style="background: #2d2d2d; padding: 10px; border-radius: 4px; overflow-x: auto;">
                                    <pre style="margin: 0; color: #d4d4d4; font-size: 0.9em;">${formattedJson}</pre>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    viewer.innerHTML = `
                        <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #667eea;">
                            <strong style="color: #667eea;">Bot: ${data.bot_name}</strong><br>
                            <span style="color: #f59e0b;">Total Events: ${events.length}</span>
                        </div>
                        ${eventsHtml}
                    `;
                } else {
                    viewer.innerHTML = `<div style="color: #ef4444;">${data.message || 'Error loading reward events'}</div>`;
                }
            } catch (error) {
                viewer.innerHTML = `<div style="color: #ef4444;">Error: ${error.message}</div>`;
            }
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initCharts();
            refreshData();
            // Auto-refresh every 2 seconds
            setInterval(refreshData, 2000);
        });
    </script>
</body>
</html>
